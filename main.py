from fastapi import FastAPI, Request
from pydantic import BaseModel
from fastapi.responses import JSONResponse, FileResponse
from sse_starlette.sse import EventSourceResponse
import sqlite3
import matplotlib.pyplot as plt
import asyncio
import os
import google.generativeai as genai
import re

# ðŸ”‘ Gemini API Key Setup
GEMINI_API_KEY = "AIzaSyA6ahQqrcEQBPSpinG39grTV3mq-0bQTh4"
genai.configure(api_key=GEMINI_API_KEY)
model = genai.GenerativeModel("models/gemini-1.5-flash")

app = FastAPI()

# âœ… Input Schema
class QuestionRequest(BaseModel):
    question: str

# âœ… Convert natural language to SQL
def get_sql_from_question(question: str) -> str:
    prompt = f"""
You are a helpful assistant that converts user questions into valid **SQLite SQL queries**.

ðŸŽ¯ Tables and Columns:

ðŸ“Š ad_sales_metrics:
- date
- item_id
- ad_sales
- impressions
- ad_spend
- clicks
- units_sold

ðŸ“¦ total_sales_metrics:
- eligibility_datetime_utc
- item_id
- eligibility
- message

âœ… eligibility_table:
- date
- item_id
- total_sales
- total_units_ordered

ðŸ§  Special Instructions:
- To calculate **RoAS (Return on Ad Spend)**:
    SELECT SUM(eligibility_table.total_sales) / SUM(ad_sales_metrics.ad_spend)
    FROM ad_sales_metrics
    JOIN eligibility_table ON ad_sales_metrics.item_id = eligibility_table.item_id
- Use only the columns listed above.
- Do NOT divide ad_spend by itself.
- Return only raw SQL. No markdown. No explanation. No comments.

Question: {question}
SQL:
"""
    try:
        response = model.generate_content(prompt)
        sql = response.text.strip()
        sql = re.sub(r"^```sql\s*|```$", "", sql, flags=re.IGNORECASE).strip()
        return sql
    except Exception as e:
        return f"-- ERROR: {e}"

# âœ… Run SQL query
def run_query(sql: str):
    try:
        conn = sqlite3.connect("ecommerce.db")
        cursor = conn.cursor()
        cursor.execute(sql)
        result = cursor.fetchall()
        columns = [col[0] for col in cursor.description]
        conn.close()
        return [dict(zip(columns, row)) for row in result]
    except Exception as e:
        return {"error": str(e)}

# âœ… POST endpoint to ask questions
@app.post("/ask")
async def ask_question(request: QuestionRequest):
    print(f"ðŸ‘‰ Question received: {request.question}")
    sql = get_sql_from_question(request.question)
    print(f"ðŸ§  SQL generated by LLM: {sql}")
    result = run_query(sql)
    print(f"ðŸ“¦ Query result: {result}")
    return JSONResponse(content=result)

# âœ… GET graph of daily ad sales
@app.get("/graph/daily-sales")
def get_sales_graph():
    conn = sqlite3.connect("ecommerce.db")
    cursor = conn.cursor()
    cursor.execute("SELECT date, SUM(ad_sales) FROM ad_sales_metrics GROUP BY date")
    results = cursor.fetchall()
    conn.close()

    dates = [row[0] for row in results]
    sales = [row[1] for row in results]

    plt.figure(figsize=(10, 4))
    plt.plot(dates, sales, marker='o', color='blue')
    plt.title("ðŸ“Š Daily Ad Sales")
    plt.xlabel("Date")
    plt.ylabel("Ad Sales")
    plt.xticks(rotation=45)
    plt.tight_layout()

    img_path = "daily_sales.png"
    plt.savefig(img_path)
    plt.close()

    return FileResponse(img_path, media_type="image/png")

# âœ… Event Streaming: Simulated real-time answer
@app.get("/stream_answer")
async def stream_answer():
    async def event_generator():
        words = "Your total sales are â‚¹52,942.21".split()
        for word in words:
            yield {
                "event": "message",
                "data": word
            }
            await asyncio.sleep(0.3)
    return EventSourceResponse(event_generator())
